"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const cosmiconfig = require("cosmiconfig");
const cosmiconfig_typescript_loader_1 = require("@endemolshinegroup/cosmiconfig-typescript-loader");
const path_1 = require("path");
const fs_1 = require("fs");
const fp_1 = require("lodash/fp");
const vscode_uri_1 = require("vscode-uri");
exports.DefaultEngineStatsWindow = {
    to: -0,
    from: -86400
};
exports.DefaultEngineConfig = {
    endpoint: "https://engine-graphql.apollographql.com/api/graphql",
    frontend: "https://engine.apollographql.com"
};
exports.DefaultConfigBase = {
    includes: ["src/**/*.{ts,tsx,js,jsx,graphql}"],
    excludes: ["**/node_modules", "**/__tests__"]
};
exports.DefaultClientConfig = Object.assign({}, exports.DefaultConfigBase, { tagName: "gql", clientOnlyDirectives: ["connection", "type"], clientSchemaDirectives: ["client", "rest"], addTypename: true, statsWindow: exports.DefaultEngineStatsWindow });
exports.DefaultServiceConfig = Object.assign({}, exports.DefaultConfigBase, { endpoint: {
        url: "http://localhost:4000/graphql"
    } });
const MODULE_NAME = "apollo";
const defaultSearchPlaces = [
    "package.json",
    `${MODULE_NAME}.config.js`,
    `${MODULE_NAME}.config.ts`
];
const getSearchPlaces = (configFile) => [
    ...(configFile ? [configFile] : []),
    ...defaultSearchPlaces
];
const loaders = {
    ".json": cosmiconfig.loadJson,
    ".js": cosmiconfig.loadJs,
    ".ts": {
        async: cosmiconfig_typescript_loader_1.default
    }
};
exports.projectsFromConfig = (config, configURI) => {
    const configs = [];
    const { client, service } = config, rest = __rest(config, ["client", "service"]);
    if (client)
        configs.push(new ClientConfig(config, configURI));
    if (service)
        configs.push(new ServiceConfig(config, configURI));
    return configs;
};
exports.parseServiceSpecificer = (specifier) => {
    const [id, tag] = specifier.split("@").map(x => x.trim());
    return [id, tag];
};
exports.getServiceName = (config) => {
    if (config.service)
        return config.service.name;
    if (config.client) {
        if (typeof config.client.service === "string") {
            return exports.parseServiceSpecificer(config.client
                .service)[0];
        }
        return config.client.service && config.client.service.name;
    }
    else {
        return undefined;
    }
};
class ApolloConfig {
    constructor(rawConfig, configURI) {
        this.rawConfig = rawConfig;
        this.configURI = configURI;
        this.isService = !!rawConfig.service;
        this.isClient = !!rawConfig.client;
        this.engine = rawConfig.engine;
        this.name = exports.getServiceName(rawConfig);
        this.client = rawConfig.client;
        this.service = rawConfig.service;
    }
    get configDirURI() {
        return this.configURI && this.configURI.fsPath.includes(".js")
            ? vscode_uri_1.default.parse(path_1.dirname(this.configURI.fsPath))
            : this.configURI;
    }
    get projects() {
        return exports.projectsFromConfig(this.rawConfig, this.configURI);
    }
    set tag(tag) {
        this._tag = tag;
    }
    get tag() {
        if (this._tag)
            return this._tag;
        let tag = "current";
        if (this.client && typeof this.client.service === "string") {
            const specifierTag = exports.parseServiceSpecificer(this.client
                .service)[1];
            if (specifierTag)
                tag = specifierTag;
        }
        return tag;
    }
    setDefaults({ client, engine, service }) {
        const config = fp_1.merge(this.rawConfig, { client, engine, service });
        this.rawConfig = config;
        this.client = config.client;
        this.service = config.service;
        if (engine)
            this.engine = config.engine;
    }
}
exports.ApolloConfig = ApolloConfig;
class ClientConfig extends ApolloConfig {
}
exports.ClientConfig = ClientConfig;
class ServiceConfig extends ApolloConfig {
}
exports.ServiceConfig = ServiceConfig;
function isClientConfig(config) {
    return config.isClient;
}
exports.isClientConfig = isClientConfig;
function isLocalServiceConfig(config) {
    return !!config.localSchemaFile;
}
exports.isLocalServiceConfig = isLocalServiceConfig;
function isServiceConfig(config) {
    return config.isService;
}
exports.isServiceConfig = isServiceConfig;
const getServiceFromKey = (key) => {
    if (key) {
        const [type, service] = key.split(":");
        if (type === "service")
            return service;
    }
    return;
};
exports.loadConfig = async ({ configPath, configFileName, requireConfig = false, name, type }) => {
    const explorer = cosmiconfig(MODULE_NAME, {
        searchPlaces: getSearchPlaces(configFileName),
        loaders
    });
    let loadedConfig = (await explorer.search(configPath));
    if (loadedConfig && loadedConfig.filepath.endsWith("package.json")) {
        console.warn('The "apollo" package.json configuration key will no longer be supported in Apollo v3. Please use the apollo.config.js file for Apollo project configuration. For more information, see: https://bit.ly/2ByILPj');
    }
    if (requireConfig && !loadedConfig) {
        throw new Error(`No Apollo config found for project. For more information, please refer to:
      https://bit.ly/2ByILPj`);
    }
    let engineConfig = {}, nameFromKey;
    const dotEnvPath = configPath
        ? path_1.resolve(configPath, ".env")
        : path_1.resolve(process.cwd(), ".env");
    if (fs_1.existsSync(dotEnvPath)) {
        const env = require("dotenv").parse(fs_1.readFileSync(dotEnvPath));
        if (env["ENGINE_API_KEY"]) {
            engineConfig = { engine: { apiKey: env["ENGINE_API_KEY"] } };
            nameFromKey = getServiceFromKey(env["ENGINE_API_KEY"]);
        }
    }
    let resolvedName = name || nameFromKey;
    let resolvedType;
    if (type) {
        resolvedType = type;
        if (loadedConfig &&
            loadedConfig.config.client &&
            typeof loadedConfig.config.client.service === "string") {
            resolvedName = loadedConfig.config.client.service;
        }
    }
    else if (loadedConfig && loadedConfig.config.client) {
        resolvedType = "client";
        resolvedName =
            typeof loadedConfig.config.client.service === "string"
                ? loadedConfig.config.client.service
                : resolvedName;
    }
    else if (loadedConfig && loadedConfig.config.service) {
        resolvedType = "service";
    }
    else {
        throw new Error("Unable to resolve project type. Please add either a client or service config. For more information, please refer to https://bit.ly/2ByILPj");
    }
    if (!loadedConfig || resolvedName) {
        loadedConfig = {
            isEmpty: false,
            filepath: configPath || process.cwd(),
            config: Object.assign({}, (loadedConfig && loadedConfig.config), (resolvedType === "client"
                ? {
                    client: Object.assign({}, exports.DefaultConfigBase, (loadedConfig && loadedConfig.config.client), { service: resolvedName })
                }
                : {
                    service: Object.assign({}, exports.DefaultConfigBase, (loadedConfig && loadedConfig.config.service), { name: resolvedName })
                }))
        };
    }
    let { config, filepath, isEmpty } = loadedConfig;
    if (isEmpty) {
        throw new Error(`Apollo config found at ${filepath} is empty. Please add either a client or service config`);
    }
    if (config.client)
        config = fp_1.merge({ client: exports.DefaultClientConfig }, config);
    if (config.service)
        config = fp_1.merge({ service: exports.DefaultServiceConfig }, config);
    if (engineConfig)
        config = fp_1.merge(engineConfig, config);
    config = fp_1.merge({ engine: exports.DefaultEngineConfig }, config);
    return new ApolloConfig(config, vscode_uri_1.default.file(path_1.resolve(filepath)));
};
//# sourceMappingURL=config.js.map