"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const heroku_cli_util_1 = require("heroku-cli-util");
const graphql_1 = require("graphql");
const chalk_1 = require("chalk");
const git_1 = require("../../git");
const Command_1 = require("../../Command");
const utils_1 = require("../../utils");
var ChangeType;
(function (ChangeType) {
    ChangeType["FAILURE"] = "FAILURE";
    ChangeType["WARNING"] = "WARNING";
    ChangeType["NOTICE"] = "NOTICE";
})(ChangeType || (ChangeType = {}));
const formatChange = (change) => {
    let color = (x) => x;
    if (change.type === ChangeType.FAILURE) {
        color = chalk_1.default.red;
    }
    if (change.type === ChangeType.WARNING) {
        color = chalk_1.default.yellow;
    }
    return {
        type: color(change.type),
        code: color(change.code),
        description: color(change.description)
    };
};
class ServiceCheck extends Command_1.ProjectCommand {
    async run() {
        const { gitContext, checkSchemaResult } = await this.runTasks(({ config, flags, project }) => [
            {
                title: "Checking service for changes",
                task: async (ctx) => {
                    if (!config.name) {
                        throw new Error("No service found to link to Engine");
                    }
                    const tag = flags.tag || config.tag || "current";
                    const schema = await project.resolveSchema({ tag });
                    ctx.gitContext = await git_1.gitInfo();
                    const historicParameters = utils_1.validateHistoricParams({
                        validationPeriod: flags.validationPeriod,
                        queryCountThreshold: flags.queryCountThreshold,
                        queryCountThresholdPercentage: flags.queryCountThresholdPercentage
                    });
                    ctx.checkSchemaResult = await project.engine.checkSchema(Object.assign({ id: config.name, schema: graphql_1.introspectionFromSchema(schema).__schema, tag: flags.tag, gitContext: ctx.gitContext, frontend: flags.frontend || config.engine.frontend }, (historicParameters && { historicParameters })));
                }
            }
        ]);
        const { targetUrl, diffToPrevious } = checkSchemaResult;
        const { changes } = diffToPrevious;
        const failures = changes.filter(({ type }) => type === ChangeType.FAILURE);
        if (changes.length === 0) {
            return this.log("\nNo changes present between schemas\n");
        }
        this.log("\n");
        heroku_cli_util_1.table(changes.map(formatChange), {
            columns: [
                { key: "type", label: "Change" },
                { key: "code", label: "Code" },
                { key: "description", label: "Description" }
            ]
        });
        this.log("\n");
        if (failures.length > 0) {
            this.exit();
        }
        return;
    }
}
ServiceCheck.aliases = ["schema:check"];
ServiceCheck.description = "Check a service against known operation workloads to find breaking changes";
ServiceCheck.flags = Object.assign({}, Command_1.ProjectCommand.flags, { tag: command_1.flags.string({
        char: "t",
        description: "The published tag to check this service against"
    }), validationPeriod: command_1.flags.string({
        description: "The size of the time window with which to validate the schema against. You may provide a number (in seconds), or an ISO8601 format duration for more granularity (see: https://en.wikipedia.org/wiki/ISO_8601#Durations)"
    }), queryCountThreshold: command_1.flags.integer({
        description: "Minimum number of requests within the requested time window for a query to be considered."
    }), queryCountThresholdPercentage: command_1.flags.integer({
        description: "Number of requests within the requested time window for a query to be considered, relative to total request count. Expected values are between 0 and 0.05 (minimum 5% of total request volume)"
    }) });
exports.default = ServiceCheck;
//# sourceMappingURL=check.js.map