"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const graphql_1 = require("graphql");
const git_1 = require("../../git");
const Command_1 = require("../../Command");
const vscode_uri_1 = require("vscode-uri");
const path_1 = require("path");
const validateOperations_1 = require("apollo-language-server/lib/engine/operations/validateOperations");
const chalk_1 = require("chalk");
const errorPriority = {
    [validateOperations_1.ValidationErrorType.INVALID]: 0,
    [validateOperations_1.ValidationErrorType.FAILURE]: 1,
    [validateOperations_1.ValidationErrorType.WARNING]: 2
};
class ClientCheck extends Command_1.ClientCommand {
    constructor() {
        super(...arguments);
        this.logMessagesForOperation = ({ validationResults, operation }) => {
            const { name, locationOffset, relativePath } = operation;
            this.log(`${name}: ${chalk_1.default.blue(`${relativePath}:${locationOffset.line}`)}\n`);
            const byErrorType = validationResults.reduce((byError, validation) => {
                validation;
                byError[validation.type].push(validation);
                return byError;
            }, {
                [validateOperations_1.ValidationErrorType.INVALID]: [],
                [validateOperations_1.ValidationErrorType.FAILURE]: [],
                [validateOperations_1.ValidationErrorType.WARNING]: []
            });
            Object.values(byErrorType).map(validations => {
                if (validations.length > 0) {
                    validations.forEach(validation => {
                        this.log(this.formatValidation(validation));
                    });
                    this.log();
                }
            });
        };
        this.printStats = (validationResults, operations) => {
            const counts = validationResults.reduce((counts, { type }) => {
                switch (type) {
                    case validateOperations_1.ValidationErrorType.INVALID:
                        counts.invalid++;
                        break;
                    case validateOperations_1.ValidationErrorType.FAILURE:
                        counts.failure++;
                        break;
                    case validateOperations_1.ValidationErrorType.WARNING:
                        counts.warning++;
                }
                return counts;
            }, {
                invalid: 0,
                failure: 0,
                warning: 0
            });
            this.log(`${operations.length} total operations validated`);
            if (counts.invalid > 0) {
                this.log(chalk_1.default.cyan(`${counts.invalid} invalid document${counts.invalid > 1 ? "s" : ""}`));
            }
            if (counts.failure > 0) {
                this.log(chalk_1.default.red(`${counts.failure} failure${counts.failure > 1 ? "s" : ""}`));
            }
            if (counts.warning > 0) {
                this.log(chalk_1.default.yellow(`${counts.warning} warning${counts.warning > 1 ? "s" : ""}`));
            }
        };
    }
    async run() {
        const { validationResults, operations } = await this.runTasks(({ project, config }) => [
            {
                title: "Checking client compatibility with service",
                task: async (ctx) => {
                    if (!config.name) {
                        throw new Error("No service found to link to Engine");
                    }
                    ctx.gitContext = await git_1.gitInfo();
                    ctx.operations = Object.entries(this.project.mergedOperationsAndFragmentsForService).map(([name, doc]) => ({
                        body: graphql_1.print(doc),
                        name,
                        relativePath: path_1.relative(config.configURI ? config.configURI.fsPath : "", vscode_uri_1.default.parse(doc.definitions[0].loc.source.name).fsPath),
                        locationOffset: doc.definitions[0].loc.source.locationOffset
                    }));
                    ctx.validationResults = await project.engine.validateOperations({
                        id: config.name,
                        tag: config.tag,
                        operations: ctx.operations.map(({ body, name }) => ({
                            body,
                            name
                        })),
                        gitContext: ctx.gitContext
                    });
                }
            }
        ]);
        const messagesByOperationName = this.getMessagesByOperationName(validationResults, operations);
        this.log();
        Object.values(messagesByOperationName).forEach(this.logMessagesForOperation);
        if (validationResults.length === 0) {
            return this.log(chalk_1.default.green("\nAll operations are valid against service\n"));
        }
        this.printStats(validationResults, operations);
        const hasFailures = validationResults.some(({ type }) => type === validateOperations_1.ValidationErrorType.FAILURE ||
            type === validateOperations_1.ValidationErrorType.INVALID);
        if (hasFailures) {
            this.exit();
        }
        return;
    }
    getMessagesByOperationName(validationResults, operations) {
        return validationResults.reduce((byOperation, validationResult) => {
            const matchingOperation = operations.find(({ name }) => name === validationResult.operation.name);
            if (matchingOperation) {
                byOperation[matchingOperation.name] = {
                    operation: matchingOperation,
                    validationResults: byOperation[matchingOperation.name]
                        ? [
                            ...byOperation[matchingOperation.name].validationResults,
                            validationResult
                        ]
                        : [validationResult]
                };
            }
            return byOperation;
        }, {});
    }
    formatValidation({ type, description }) {
        let color = (x) => x;
        switch (type) {
            case validateOperations_1.ValidationErrorType.FAILURE:
                color = chalk_1.default.red;
                break;
            case validateOperations_1.ValidationErrorType.INVALID:
                color = chalk_1.default.gray;
                break;
            case validateOperations_1.ValidationErrorType.WARNING:
                color = chalk_1.default.yellow;
                break;
        }
        return `    ${color(type)}    ${description}`;
    }
}
ClientCheck.description = "Check a client project against a pushed service";
ClientCheck.flags = Object.assign({}, Command_1.ClientCommand.flags, { tag: command_1.flags.string({
        char: "t",
        description: "The published tag to check this client against"
    }) });
exports.default = ClientCheck;
//# sourceMappingURL=check.js.map